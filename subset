class Solution:
    def generate(self,ind,curr_subset,ans,nums):
        if(ind==len(nums)):
            ans.append(curr_subset.copy())
            return
        curr_subset.append(nums[ind])
        self.generate(ind+1,curr_subset,ans,nums)
        curr_subset.pop()
        self.generate(ind+1,curr_subset,ans,nums)
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ind=0
        curr_subset=[]
        ans=[]
        self.generate(ind,curr_subset,ans,nums)
        return ans

        Step	i	curr (before)	Action	curr (after)	Result added
1	0	[]	Include 1	[1]	-
2	1	[1]	Include 2	[1, 2]	-
3	2	[1, 2]	Base case	[1, 2]	[1, 2]
4	1	[1, 2]	Exclude 2 (pop)	[1]	-
5	2	[1]	Base case	[1]	[1]
6	0	[1]	Exclude 1 (pop)	[]	-
7	1	[]	Include 2	[2]	-
8	2	[2]	Base case	[2]	[2]
9	1	[2]	Exclude 2 (pop)	[]	-
10	2	[]	Base case	[]	[]
Final Result: [[1, 2], [1], [2], []]

Visual Decision Tree for [1, 2, 3]:

                        []
                    /        \
              Include 1    Exclude 1
                 [1]           []
               /    \        /    \
           +2    -2       +2    -2
          [1,2]  [1]     [2]    []
          / \    / \     / \    / \
        +3 -3  +3 -3   +3 -3  +3 -3
      [1,2,3][1,2][1,3][1][2,3][2][3][]

All 8 leaf nodes = all 8 subsets
Complexity

Time complexity: O(nâ‹…2 
n
 )
We generate 2^n subsets (each element has 2 choices). For each subset, we make a copy which takes O(n) time in the worst case (when the subset contains all n elements). Total: O(n * 2^n).

Space complexity: O(n)
Recursion depth is O(n) since we make one recursive call per element. The curr list holds at most n elements. Note: The output list res containing all 2^n subsets is not counted as auxiliary space per standard convention. If we count output space, it would be O(n * 2^n).

